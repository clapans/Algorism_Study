# SWEA 2105번



## 문제



1. 친구들과 디저트 카페 투어를 할 계획이다.

   [Fig. 1]과 같이 한 변의 길이가 N인 정사각형 모양을 가진 지역에 디저트 카페가 모여 있다.
    
   
   ![img](sw_2105.assets/fileDownload.do)
   
   
   원 안의 숫자는 해당 디저트 카페에서 팔고 있는 디저트의 종류를 의미하고

   카페들 사이에는 대각선 방향으로 움직일 수 있는 길들이 있다.

   디저트 카페 투어는 어느 한 카페에서 출발하여

   [Fig. 2]와 같이 **대각선 방향으로 움직이고 사각형 모양을 그리며 출발한 카페로 돌아와야 한다.**
    
    

   ![img](sw_2105.assets/fileDownload-16469102987651.do)

   
   디저트 카페 투어를 하는 도중 해당 지역을 벗어나면 안 된다.
   
   또한, 친구들은 같은 종류의 디저트를 다시 먹는 것을 싫어한다.
   
   즉, [Fig. 3]과 같이 **카페 투어 중에 같은 숫자의 디저트를 팔고 있는 카페가 있으면 안 된다.**
    
    
   
   ![img](sw_2105.assets/fileDownload-16469102987652.do)
   
   

   [Fig. 4]와 같이 하나의 카페에서 디저트를 먹는 것도 안 된다.

    

   ![img](sw_2105.assets/fileDownload-16469102987653.do)

   
   [Fig. 5]와 같이 왔던 길을 다시 돌아가는 것도 안 된다.
    

   ![img](sw_2105.assets/fileDownload-16469102987654.do)

    

   친구들과 디저트를 되도록 많이 먹으려고 한다.

   디저트 가게가 모여있는 지역의 한 변의 길이 N과 디저트 카페의 디저트 종류가 입력으로 주어질 때,
   
   임의의 한 카페에서 출발하여 대각선 방향으로 움직이고
   
   서로 다른 디저트를 먹으면서 사각형 모양을 그리며 다시 출발점으로 돌아오는 경우,
   
   디저트를 가장 많이 먹을 수 있는 경로를 찾고, 그 때의 디저트 수를 정답으로 출력하는 프로그램을 작성하라.
   
   만약, 디저트를 먹을 수 없는 경우 -1을 출력한다.
   
   
   **[예시]**
   
   한 변의 길이 N이 4인 지역에 디저트 카페가 [Fig. 6]과 같이 있다고 생각하자.
    

   ![img](sw_2105.assets/fileDownload-16469102987655.do)

   

   디저트 카페 투어가 가능한 경우는 [Fig. 7]과 같이 5가지로 나눌 수 있다.

   (출발한 곳과 도는 방향은 다를 수 있지만, 디저트 카페 투어의 경로가 그리는 사각형 모양은 5가지 중 하나이다.)

    
   
   ![img](sw_2105.assets/fileDownload-16469102987656.do)
   
   [Fig. 7]
   
    
   이 중에 디저트를 가장 많이 먹을 수 있는 경우는 ⑤인 경우로 디저트의 종류는 6개이다.
   
   따라서, 정답은 6이 된다.
   
   
   **[제약사항]**
   
   1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는 데 C/C++/Java 모두 3초
   
   2. 디저트 카페가 모여있는 지역의 한 변의 길이 N은 4 이상 20 이하의 정수이다. (4 ≤ N ≤ 20)
   
   3. 디저트 종류를 나타나는 수는 1 이상 100 이하의 정수이다.

---

### 입력



입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 디저트 카페가 모여있는 지역의 한 변의 길이 N이 주어진다.

그 다음 N 줄에는 N * N 크기의 디저트 카페에서 팔고 있는 디저트 종류에 대한 정보가 주어진다.

---

### 출력



테스트 케이스 개수만큼 T개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.

각 줄은 "#t"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (t는 1부터 시작하는 테스트 케이스의 번호이다)

출력해야 할 정답은 가능한 경우 중 디저트를 가장 많이 먹을 때의 디저트 수 이다.

만약, 디저트를 먹을 수 없는 경우 정답은 -1이다.

---

## Point



1. dfs로 접근 순회하는 모양이 항상 같은 모양이기 때문에 탐색하는 지점에 대해 시계방향으로 도는 거만을 계산
1. 한번 방향을 틀면 이전에 썼던 방향은 다시 못 쓰게 설계
1. 방문했던 곳은 어짜피 갈 수도 없고 배열의 값이 이전에 방문했던 곳들 중에 있는 지 확인하는 절차가 필요하기 때문에 방문처리하는 배열은 따로 쓰지 않고 append,pop으로 설계



## CODE

```python
dx = [1,1,-1,-1]
dy = [1,-1,-1,1]
 
def dfs(x,y,val,dir):
    global res
    if x == sx and y == sy and val:
        res = max(res,len(val))
    else:
        try:
            if dir[-1] < 3:
                case = [dir[-1],dir[-1]+1]
            else:
                case = [dir[-1]]
        except:
            case = [0]
        for t in case:
            nx = x + dx[t]
            ny = y + dy[t]
            if 0 <= nx < n and 0 <= ny < n and arr[nx][ny] not in val:
                val.append(arr[nx][ny])
                dir.append(t)
                dfs(nx,ny,val,dir)
                dir.pop()
                val.pop()
 
for case in range(int(input())):
    n = int(input())
    arr = []
    for _ in range(n):
        arr.append(list(map(int,input().split())))
    res = -1
    for i in range(n):
        for j in range(n):
            sx,sy = i,j
            dfs(i,j,[],[])
    print(f'#{case+1} {res}')

```

